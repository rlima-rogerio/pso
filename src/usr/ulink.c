#include "ulink.h"
#include "ulink_types.h"
#include "ulink_pso.h"
#include "checksum.h"

uint16_t uart_rx_buffer[ULINK_MAX_PACKET_LEN];
uint16_t uart_tx_buffer[ULINK_MAX_PACKET_LEN];
ulink_pso_data_t dp;

extern volatile uint32_t adc0_buffer[3];      /* Ax - Thr - V_m */
extern volatile uint32_t adc1_buffer[3];      /* Ay -  Az - I_m */
extern uint32_t delta;  /* RPM */
extern uint8_t g_timer_a3_scan_flag;
extern uint8_t pwm_throttle;

ulink_pso_command_t command;


ulink_system_t ulink_system;

// Write message on an "UART Tx buffer"
void uart_write ()
{
	ulink_pso_data_t dp;

    ulink_system.sysid = 0;
    ulink_system.compid = 0;

    memset(&dp, 0, sizeof(dp));

    dp.accel[0] = (int16_t)adc0_buffer[0];	/* x-axis vibration */
    dp.accel[1] = (int16_t)adc1_buffer[0];  /* y-axis vibration */
    dp.accel[2] = (int16_t)adc1_buffer[1];  /* z-axis vibration */
    dp.rpm = 1750U;     /* Revolutions per minute */
    dp.i_motor = (int16_t)adc1_buffer[2];    /* Current of the motor, [A] */
    dp.v_motor = (int16_t)adc0_buffer[2];  /* Voltage applied to the motor, [V] */
    dp.thrust = (int16_t)adc0_buffer[1];     /* Force generated by the motor + propeller, [N] */

	memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));

	create_message(ulink_system.sysid, ulink_system.compid, uart_tx_buffer, &dp);
}



// Read from 'UART Rx buffer' and translate message to variable 'command'.
int uart_read(){

	int i;
	uint16_t buffer[ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_NUM_NON_PAYLOAD_BYTES];

	memset(buffer, 0, sizeof(buffer));

	for (i = 0; i < ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_NUM_NON_PAYLOAD_BYTES; i++){
		if(i%2==0){
			buffer[i/2] |= uart_rx_buffer[i];
		}else{
			buffer[i/2] |= uart_rx_buffer[i] << 8;
		}
	}
	if(parse_message(buffer, &command)){
	    //Retrieve the message payload and return

		printf("\nGUMSTIX_INFORMATION: New message read\n");

	    return 0;
	}

	//printf("\nGUMSTIX_INFORMATION: Failed to parse message...\n");
	// FAIL
	return -1;

}



void create_message(uint8_t system_id, uint8_t component_id, uint16_t* msg, const ulink_pso_data_t* pso_data){
	uint16_t checksum;

	memcpy(&msg[6], pso_data, sizeof(ulink_pso_data_t));

	msg[0] |= ULINK_STX;
	msg[1] |= ULINK_MSG_ID_PSO_DATA_LEN;
	msg[2] |= 0x23;
	msg[3] |= system_id;
	msg[4] |= component_id;
	msg[5] |= ULINK_MSG_ID_PSO_DATA;

	checksum = create_checksum(&msg[0], ULINK_MSG_ID_PSO_DATA_LEN + ULINK_CORE_HEADER_LEN);
	accumulate_checksum(ULINK_MSG_ID_PSO_DATA_CRC, &checksum);

	msg[6 + ULINK_MSG_ID_PSO_DATA_LEN] = checksum;

	/*
	memcpy(&msg[3], pso_data, sizeof(ulink_pso_data_t));

	msg[2] |= ULINK_MSG_ID_PSO_DATA << 8;

	msg[0] |= ULINK_STX;
	msg[0] |= ULINK_MSG_ID_PSO_DATA_LEN << 8;
	msg[1] |= system_id << 8;
	msg[2] |= component_id;

	checksum = create_checksum(&msg[0], ULINK_MSG_ID_PSO_DATA_LEN + ULINK_CORE_HEADER_LEN);
	accumulate_checksum(ULINK_MSG_ID_PSO_DATA_CRC, &checksum);

	msg[3 + ULINK_MSG_ID_PSO_DATA_LEN/2] = checksum;
	*/
}

uint16_t create_checksum(uint16_t* msg, uint16_t length){
	int i;
    uint16_t crcTmp;
    crc_init(&crcTmp);
    i=1;

    while (length--)
    {
    	accumulate_checksum(msg[i] & 0xff, &crcTmp);
        ++i;
    }

    /*
    while (length--) {
    	if(i%2==0){
    		accumulate_checksum(msg[i/2] & 0xff, &crcTmp);
    	}else{
    		accumulate_checksum((msg[i/2] >> 8) & 0xff, &crcTmp);
    	}
        ++i;
    }
    */

    return crcTmp;
}

void accumulate_checksum(uint8_t data, uint16_t *crcAccum){
    /*Accumulate one byte of data into the CRC*/
    uint8_t tmp;

    tmp = data ^ (*crcAccum &0xff);
    tmp ^= (tmp<<4) &0xff;
    *crcAccum = (*crcAccum>>8) ^ (tmp<<8) ^ (tmp <<3) ^ (tmp>>4);
}

uint8_t parse_message(uint16_t *msg, ulink_pso_command_t *command){
	uint16_t checksum = create_checksum(msg, ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_CORE_HEADER_LEN);
	accumulate_checksum(ULINK_MSG_ID_PSO_COMMAND_CRC, &checksum);

	if(checksum == msg[6 + ULINK_MSG_ID_PSO_COMMAND_LEN]){
			memcpy(command, &msg[6], sizeof(ulink_pso_command_t));
			return 1;
		}

	/*
	if(checksum == msg[3 + ULINK_MSG_ID_PSO_COMMAND_LEN/2]){
		memcpy(command, &msg[3], sizeof(ulink_pso_command_t));
		return 1;
	}
	*/

	return 0;
}



void copy_data (uint16_t* uart_tx_buf, ulink_pso_data_t* dp)
{
	uint16_t aux;
	static uint16_t index = 0;

	dp->index = index;

	memset(uart_tx_buf, 0, sizeof(uart_tx_buf));


	uart_tx_buf[0] = ULINK_STX;
	uart_tx_buf[1] = ULINK_MSG_ID_PSO_DATA_LEN;
	uart_tx_buf[2] = 0x00FF & (dp->index >> 8);
	uart_tx_buf[3] = 0x00FF & (dp->index);
	uart_tx_buf[4] = 0x00FF & (dp->accel[0] >> 8);
	uart_tx_buf[5] = 0x00FF & (dp->accel[0]);
	uart_tx_buf[6] = 0x00FF & (dp->accel[1] >> 8);
	uart_tx_buf[7] = 0x00FF & (dp->accel[1]);
	uart_tx_buf[8] = 0x00FF & (dp->accel[2] >> 8);
	uart_tx_buf[9] = 0x00FF & (dp->accel[2]);
	uart_tx_buf[10] = 0x00FF & (dp->rpm >> 8);
	uart_tx_buf[11] = 0x00FF & (dp->rpm);
	uart_tx_buf[12] = 0x00FF & (dp->i_motor >> 8);
	uart_tx_buf[13] = 0x00FF & (dp->i_motor);
	uart_tx_buf[14] = 0x00FF & (dp->v_motor >> 8);
	uart_tx_buf[15] = 0x00FF & (dp->v_motor);
	uart_tx_buf[16] = 0x00FF & (dp->thrust >> 8);
	uart_tx_buf[17] = 0x00FF & (dp->thrust);
	uart_tx_buf[18] = dp->throttle;

	aux = create_checksum(uart_tx_buf, 18);

	uart_tx_buf[19] = 0x00FF & (aux >> 8);
	uart_tx_buf[20] = 0x00FF & (aux);

	dp->index = index++;
}

/*******************************************************************************
* Function Name  : packet_data
* Input          : None
* Output         : ulink_pso_data_t* dp
* Return         : 1 if success, 0 if fail
* Description    : Writes a pre-defined number of bytes (bytesToWrite) stored
*                  in (txBuffer) into the UART addressed by (ui32Base) address.
*                  Copy data to txBuffer just prior send it over UART.
*******************************************************************************/
uint8_t packet_data (ulink_pso_data_t* dp)
{
    uint8_t returnval;
//    static uint32_t delta = 0;
//    static uint32_t tav_1 = 0U; /* Previous edge count */

//    delta = wt1cpp0_tav_buffer - tav_1;

    /* Updates the RPM variable only once per second */
//    if (g_timer_a3_scan_flag)
//    {
//    	delta = wt1cpp0_tav_buffer - tav_1;
//    	tav_1 = wt1cpp0_tav_buffer;
//    	g_timer_a3_scan_flag = 0U;
//    }

    dp->accel[0] = (int16_t)adc0_buffer[0];	/* x-axis vibration */
    dp->accel[1] = (int16_t)adc1_buffer[0]; /* y-axis vibration */
    dp->accel[2] = (int16_t)adc1_buffer[1]; /* z-axis vibration */
    dp->rpm      = (int16_t)delta;          /* Revolutions per minute */
    dp->i_motor  = (int16_t)adc1_buffer[2]; /* Current of the motor, [A] */
    dp->v_motor  = (int16_t)adc0_buffer[2]; /* Voltage applied to the motor, [V] */
    dp->thrust   = (int16_t)adc0_buffer[1]; /* Force generated by the motor + propeller, [N] */
    dp->throttle = pwm_throttle;            /* Throttle applied to the ESC, [0 ~ 100] */


    return returnval;
}
