#include <string.h>   // Para memset
#include <stdio.h>    // Para printf
#include "ulink.h"
#include "ulink_types.h"
#include "ulink_pso.h"
#include "checksum.h"
#include "pso_rpm.h"
#include "pso_iv.h"

uint16_t uart_rx_buffer[ULINK_MAX_PACKET_LEN];
uint16_t uart_tx_buffer[ULINK_MAX_PACKET_LEN];
ulink_pso_data_t dp;

extern volatile uint32_t adc0_buffer[3];      /* Ax - Thr - V_m */
extern volatile uint32_t adc1_buffer[3];      /* Ay -  Az - I_m */

extern uint8_t g_pwm_value;
extern uint32_t g_scaled_rpm;

ulink_pso_command_t command;


ulink_system_t ulink_system;

// Write message on an "UART Tx buffer"
void uart_write ()
{
	ulink_pso_data_t dp;

    ulink_system.sysid = 0;
    ulink_system.compid = 0;

    memset(&dp, 0, sizeof(dp));

    dp.accel[0] = (int16_t)adc0_buffer[0];	/* x-axis vibration */
    dp.accel[1] = (int16_t)adc1_buffer[0];  /* y-axis vibration */
    dp.accel[2] = (int16_t)adc1_buffer[1];  /* z-axis vibration */
    dp.rpm = 1750U;     /* Revolutions per minute */
    dp.i_motor = (uint16_t)adc1_buffer[2];    /* Current of the motor, [A] */
    dp.v_motor = (uint16_t)adc0_buffer[2];  /* Voltage applied to the motor, [V] */
    dp.thrust = (int16_t)adc0_buffer[1];     /* Force generated by the motor + propeller, [N] */

	memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));

	create_message(ulink_system.sysid, ulink_system.compid, uart_tx_buffer, &dp);
}



// Read from 'UART Rx buffer' and translate message to variable 'command'.
int uart_read(){

	int i;
	uint16_t buffer[ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_NUM_NON_PAYLOAD_BYTES];

	memset(buffer, 0, sizeof(buffer));

	for (i = 0; i < ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_NUM_NON_PAYLOAD_BYTES; i++){
		if(i%2==0){
			buffer[i/2] |= uart_rx_buffer[i];
		}else{
			buffer[i/2] |= uart_rx_buffer[i] << 8;
		}
	}
	if(parse_message(buffer, &command)){
	    //Retrieve the message payload and return

		printf("\nGUMSTIX_INFORMATION: New message read\n");

	    return 0;
	}

	return -1;

}



void create_message(uint8_t system_id, uint8_t component_id, uint16_t* msg, const ulink_pso_data_t* pso_data){
	uint16_t checksum;

	memcpy(&msg[6], pso_data, sizeof(ulink_pso_data_t));

	msg[0] |= ULINK_STX;
	msg[1] |= ULINK_MSG_ID_PSO_DATA_LEN;
	msg[2] |= 0x23;
	msg[3] |= system_id;
	msg[4] |= component_id;
	msg[5] |= ULINK_MSG_ID_PSO_DATA;

	checksum = create_checksum(&msg[0], ULINK_MSG_ID_PSO_DATA_LEN + ULINK_CORE_HEADER_LEN);
	accumulate_checksum(ULINK_MSG_ID_PSO_DATA_CRC, &checksum);

	msg[6 + ULINK_MSG_ID_PSO_DATA_LEN] = checksum;

}

uint16_t create_checksum(uint16_t* msg, uint16_t length){
	int i;
    uint16_t crcTmp;
    crc_init(&crcTmp);
    i=1;

    while (length--)
    {
    	accumulate_checksum(msg[i] & 0xff, &crcTmp);
        ++i;
    }

    return crcTmp;
}

void accumulate_checksum(uint8_t data, uint16_t *crcAccum){
    /*Accumulate one byte of data into the CRC*/
    uint8_t tmp;

    tmp = data ^ (*crcAccum &0xff);
    tmp ^= (tmp<<4) &0xff;
    *crcAccum = (*crcAccum>>8) ^ (tmp<<8) ^ (tmp <<3) ^ (tmp>>4);
}

uint8_t parse_message(uint16_t *msg, ulink_pso_command_t *command){
	uint16_t checksum = create_checksum(msg, ULINK_MSG_ID_PSO_COMMAND_LEN + ULINK_CORE_HEADER_LEN);
	accumulate_checksum(ULINK_MSG_ID_PSO_COMMAND_CRC, &checksum);

	if(checksum == msg[6 + ULINK_MSG_ID_PSO_COMMAND_LEN]){
			memcpy(command, &msg[6], sizeof(ulink_pso_command_t));
			return 1;
		}


	return 0;
}



void copy_data (uint16_t* uart_tx_buf, ulink_pso_data_t* dp)
{
	uint16_t aux;
	static uint16_t index = 0;

	dp->index = index;

	memset(uart_tx_buf, 0, sizeof(uart_tx_buf));


	uart_tx_buf[0] = ULINK_STX;
	uart_tx_buf[1] = ULINK_MSG_ID_PSO_DATA_LEN;
	uart_tx_buf[2] = 0x00FF & (dp->index >> 8);
	uart_tx_buf[3] = 0x00FF & (dp->index);
	uart_tx_buf[4] = 0x00FF & (dp->accel[0] >> 8);
	uart_tx_buf[5] = 0x00FF & (dp->accel[0]);
	uart_tx_buf[6] = 0x00FF & (dp->accel[1] >> 8);
	uart_tx_buf[7] = 0x00FF & (dp->accel[1]);
	uart_tx_buf[8] = 0x00FF & (dp->accel[2] >> 8);
	uart_tx_buf[9] = 0x00FF & (dp->accel[2]);
	uart_tx_buf[10] = 0x00FF & (dp->rpm >> 8);
	uart_tx_buf[11] = 0x00FF & (dp->rpm);
	uart_tx_buf[12] = 0x00FF & (dp->i_motor >> 8);
	uart_tx_buf[13] = 0x00FF & (dp->i_motor);
	uart_tx_buf[14] = 0x00FF & (dp->v_motor >> 8);
	uart_tx_buf[15] = 0x00FF & (dp->v_motor);
	uart_tx_buf[16] = 0x00FF & (dp->thrust >> 8);
	uart_tx_buf[17] = 0x00FF & (dp->thrust);
	uart_tx_buf[18] = dp->throttle;

	aux = create_checksum(uart_tx_buf, 18);

	uart_tx_buf[19] = 0x00FF & (aux >> 8);
	uart_tx_buf[20] = 0x00FF & (aux);

	dp->index = index++;
}

/*******************************************************************************
* Function Name  : packet_data
* Input          : None
* Output         : ulink_pso_data_t* dp
* Return         : 1 if success, 0 if fail
* Description    : Writes a pre-defined number of bytes (bytesToWrite) stored
*                  in (txBuffer) into the UART addressed by (ui32Base) address.
*                  Copy data to txBuffer just prior send it over UART.
*******************************************************************************/
//  uint8_t packet_data (ulink_pso_data_t* dp)
//  {
//      uint8_t returnval = 0U;

//      dp->accel[0] = (int16_t)adc0_buffer[0];	/* x-axis vibration */
//      dp->accel[1] = (int16_t)adc1_buffer[0]; /* y-axis vibration */
//      dp->accel[2] = (int16_t)adc1_buffer[1]; /* z-axis vibration */
//      dp->rpm      = (int16_t)g_scaled_rpm;    /* Revolutions per minute */
//      dp->i_motor  = (int16_t)adc1_buffer[2]; /* Current of the motor, [A] */
//      dp->v_motor  = (int16_t)adc0_buffer[2]; /* Voltage applied to the motor, [V] */
//      dp->thrust   = (int16_t)adc0_buffer[1]; /* Force generated by the motor + propeller, [N] */
//      dp->throttle = g_pwm_value;            /* Throttle applied to the ESC, [0 ~ 100] */


//      return returnval;
//  }

/*******************************************************************************
 * PACKET DATA FUNCTION (VERSÃƒO OTIMIZADA)
 ******************************************************************************/

/**
 * @brief Fill packet with optimized scaling
 * 
 * TRANSMITED VALUES:
 *   - v_motor: millivolts (0-33400 mV)
 *   - i_motor: milliamps (0-60000 mA)
 * 
 */
uint8_t packet_data(ulink_pso_data_t* dp)
{
    uint8_t returnval = 0U;
    
    /* Acceleration (raw ADC) */
    dp->accel[0] = adc0_buffer[0];
    dp->accel[1] = adc1_buffer[0];
    dp->accel[2] = adc1_buffer[1];
    
    /* RPM */
    dp->rpm = g_scaled_rpm;
    
    /* VOLTAGE in millivolts */
    dp->v_motor = voltage_adc_to_mv(adc0_buffer[2]);
    
    /* CURRENT in milliamps */
    dp->i_motor = current_adc_to_ma(adc1_buffer[2]);
    
    /* Thrust and throttle */
    dp->thrust = adc0_buffer[1];
    dp->throttle = g_pwm_value;
    
    return returnval;
}
